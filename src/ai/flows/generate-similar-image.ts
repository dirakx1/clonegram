// This is an autogenerated file from Firebase Studio.
'use server';
/**
 * @fileOverview Flow for generating images similar to those from an Instagram account.
 *
 * - generateSimilarImage - A function that generates images similar to those from an Instagram account.
 * - GenerateSimilarImageInput - The input type for the generateSimilarImage function.
 * - GenerateSimilarImageOutput - The return type for the generateSimilarImage function.
 */

import {ai} from '@/ai/ai-instance';
import {z} from 'genkit';
import {getLatestInstagramPosts} from '@/services/instagram';

const GenerateSimilarImageInputSchema = z.object({
  instagramAccount: z.string().describe('The Instagram account to mimic.'),
  numberOfImages: z.number().default(1).describe('The number of images to generate.'),
});
export type GenerateSimilarImageInput = z.infer<typeof GenerateSimilarImageInputSchema>;

const GenerateSimilarImageOutputSchema = z.object({
  imageUrls: z.array(z.string()).describe('URLs of the generated images.'),
});
export type GenerateSimilarImageOutput = z.infer<typeof GenerateSimilarImageOutputSchema>;

export async function generateSimilarImage(input: GenerateSimilarImageInput): Promise<GenerateSimilarImageOutput> {
  return generateSimilarImageFlow(input);
}

const analyzeStyle = ai.defineTool({
  name: 'analyzeStyle',
  description: 'Analyzes a set of images and extracts the visual style, common subjects, and color palettes.',
  inputSchema: z.object({
    imageUrls: z.array(z.string()).describe('The URLs of the images to analyze.'),
  }),
  outputSchema: z.object({
    style: z.string().describe('A description of the visual style of the images.'),
    subjects: z.string().describe('A description of the common subjects in the images.'),
    colorPalette: z.string().describe('A description of the color palette used in the images.'),
  }),
},
async input => {
  // Placeholder implementation.  In a real application, this would use a
  // multi-modal model to analyze the images.
  return {
    style: 'The images have a vibrant and artistic style.',
    subjects: 'Common subjects include landscapes and portraits.',
    colorPalette: 'The color palette is warm and inviting.',
  };
});

const generateImage = ai.defineTool({
  name: 'generateImage',
  description: 'Generates an image based on a style, subject, and color palette.',
  inputSchema: z.object({
    style: z.string().describe('The style of the image to generate.'),
    subjects: z.string().describe('The subjects of the image to generate.'),
    colorPalette: z.string().describe('The color palette of the image to generate.'),
  }),
  outputSchema: z.string().describe('The URL of the generated image.'),
},
async input => {
  // Placeholder implementation.  In a real application, this would call an
  // image generation model like DALL-E or Stable Diffusion.
  return `https://example.com/generated-image-${Math.random()}.jpg`;
});

const generateSimilarImagePrompt = ai.definePrompt({
  name: 'generateSimilarImagePrompt',
  tools: [analyzeStyle, generateImage],
  prompt: `You are an AI assistant that generates images similar to a given Instagram account.\nFirst, use the analyzeStyle tool to analyze the style of the images from the Instagram account.\nThen, use the generateImage tool to generate new images with a similar style, subject matter, and color palette.\nReturn a JSON array of image URLs.
`,
});

const generateSimilarImageFlow = ai.defineFlow<
  typeof GenerateSimilarImageInputSchema,
  typeof GenerateSimilarImageOutputSchema
>({
  name: 'generateSimilarImageFlow',
  inputSchema: GenerateSimilarImageInputSchema,
  outputSchema: GenerateSimilarImageOutputSchema,
},
async input => {
  const posts = await getLatestInstagramPosts(input.instagramAccount);
  const imageUrls = posts.map(post => post.imageUrl);

  const analysis = await analyzeStyle({
    imageUrls,
  });

  const generatedImageUrls: string[] = [];
  for (let i = 0; i < input.numberOfImages; i++) {
    const imageUrl = await generateImage({
      style: analysis.style,
      subjects: analysis.subjects,
      colorPalette: analysis.colorPalette,
    });
    generatedImageUrls.push(imageUrl);
  }

  return {
    imageUrls: generatedImageUrls,
  };
});

